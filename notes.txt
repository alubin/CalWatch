DONE?! deal with recurring events
-- RecurrenceProcessor.expand() seems to do exactly what I want. Hypothetically, this is going to
   be a quick hack, if it work.

   maybe I need a better RFC 2245 (iCal) parser? Google has one:
   https://code.google.com/p/google-rfc-2445/

   Curiously, it's blowing up on the E2E VIV office hours, which has an exDate field of this:
   America/Los_Angeles;20140815T100000,20140822T100000,20140829T100000)

   The claim is that there's a "missing LHS" in the timezone part. Hrmm.

   TODO understand / fix incorrect handling of GS recurring event; maybe we need to give up on the calendarcommon thing and move to the above codebase


Port to Android Wear
-- Useful article including sample code: http://toastdroid.com/2014/07/18/developing-watchfaces-for-android-wear/
-- How to set up the damn emulator: http://www.tech-recipes.com/rx/49586/how-do-i-connect-an-android-wear-emulator-to-a-real-phone/
   adb -d forward tcp:5601 tcp:5601

    TODO verify on round face
    Kludgy way to detect if we're on round vs. square:
        http://stackoverflow.com/questions/25821544/detect-moto-360-circlular-shape-and-onapplywindowinsetlistener-not-being-called
    See also:
        http://stackoverflow.com/questions/24907557/android-wear-type-detection-round-or-square
        http://stackoverflow.com/questions/22525582/is-there-any-way-to-detect-if-the-clock-is-round

    TODO detect Moto 360 and deal with cropping
    -- only way to detect seems to be using android.os.Build.MODEL, but I don't know the value until I've got a real Moto 360.
    -- cropping code is otherwise ready to go

    TODO verify correct operation when ambient mode on phone disabled


TODO sort out how to compile protobufs automatically via Gradle (vs. known bugs lodged with Google)
-- At least the Square protobuf runtime is automatically fetched and compiled
-- Seems to be compiling correctly, might even work on the first try (ha!)

TODO fancier control panel: Material Layout cards

Verify all the weird connect/disconnect corner cases
    TODO fresh boot of phone, make sure service is up no matter what
    TODO disconnect / reconnect of phone from watch
    TODO fresh boot of watch / reconnect to old phone app
    TODO nothing running on phone / fresh watch wants data
    TODO are we recovering properly if the phone kills the service after a long hiatus?

TODO app signing

BUGS BUGs BUGZ!
  TODO incorrect handling of watch lifecycle (shock, horror)
  -- ignoring changes in the Activity seems to be helping, a bit, but we're not learning
     anything, at all, when the user covers the screen with something else. Not good. Also,
     there's some ugliness when another email or event wants to draw on top.

  -- now that we've integrated the 5-second alarm, we should try killing off the
     render thread as part of the onStop() lifecycle *and* should immediately render
     the screen when the lifecycle moves back into action. Will that work?

Notes on supporting a "real" watch face (via reading over:
https://github.com/twotoasters/watchface-template/tree/master/submodules

 Gears library:
    Activity.java: nothing interesting at all
    DeviceUtils.java: totally cheesy way of determining AMOLED: lookup
      table based on device type
    Watch.java:
      - logic to deal with changing timezones
      - onTimeChanged() via alarm manager when seconds are turned off (do we care?)
      - unclear if any of this is necessary

  mobile/src/main/AndroidMainfest.xml:
    uses-permission for background
    preview.png

  wear/src/main/AndroidManifest.xml:
    more permission usage
    some funkiness about how the activity is set up (providing background, etc.)

  Meanwhile, there's all this business about Square's various testing
  and code injection libraries. Probably not worth bothering
  now. Maybe later.



Further improvements:
  Calendar rendering:
    TODO if we've got a busy calendar on one side of the watch and a simpler one on the other side, we can have unbalanced wedges (one could be 0-5 and the other is 6-6)

    Possible solution: rather than having the current scheme where we add levels every time, we could instead start with 0 - MAXINT
    Every wedge starts out from 0 - MAXINT. When there's overlap, we add a constraint that the two not overlap. That has us
    setting up a series of constraints that a solver could go after. This.max is less than that.min. That.min is greater than this.max, but
    we want to maximize the size of each wedge *and* we want to minimize another function that measures stddev over wedge thickness when
    wedges overlap.

    A constraint solver can probably do this without breaking a sweat. Seems like overkill, but might work.

    http://jacopguide.osolpro.com/guideJaCoP.html
    http://www.constraintsolving.com/solvers/java-based-solvers

  Moto 360:
    DONE!! pull back the radius along the bottom to fit the cropped ~30 pixels -- maybe an extension to drawRadialLine that knows about the bounding box and projects the line backward
    TODO android.os.Build check for whether we're on Moto 360, then set the crop factor
